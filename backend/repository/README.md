# Repository Layer - How-To Guide

This guide explains how to create and implement repositories in this project. Repositories handle all data access logic and serve as the bridge between the service layer and the database.

## Overview

The repository layer:
- Defines interfaces for data access operations
- Implements database operations using GORM
- Uses entity models from `backend/model/entity`
- Generates mocks automatically for testing
- Provides type-safe database interactions

## Repository Creation Workflow

### Step 1: Create Entity Model

Create entity models in `backend/model/entity/<name>.go`. Entity models represent database table schemas and always use UUID as primary key.

Example: `backend/model/entity/user.go`

```go
package entity

import (
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// UserEntity represents a user in the system
type UserEntity struct {
	ID        uuid.UUID `gorm:"primaryKey"`
	Email     string
	Password  []byte
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"`
}
```

**Key Points:**
- Always use `uuid.UUID` for primary keys
- Include timestamp fields: `CreatedAt`, `UpdatedAt`
- Include `DeletedAt` for soft deletes (if needed)
- Use GORM tags for database configuration
- Name the struct `<Name>Entity` for clarity

### Step 2: Create Repository Interface

Create the repository interface in `backend/repository/interfaces/<name>.repository_interface.go`. The interface defines what operations are available for this entity.

Example: `backend/repository/interfaces/user.repository_interface.go`

```go
package interfaces

import (
	"context"

	"github.com/google/uuid"
	"github.com/kamil5b/clean-go-vite-react/backend/model/entity"
)

// UserRepository defines the interface for user data access
type UserRepository interface {
	Create(ctx context.Context, user entity.UserEntity) (*uuid.UUID, error)
	FindByID(ctx context.Context, id uuid.UUID) (*entity.UserEntity, error)
	Update(ctx context.Context, id uuid.UUID, user entity.UserEntity) error
	Delete(ctx context.Context, id uuid.UUID) error
	FindAll(ctx context.Context) ([]entity.UserEntity, error)
}
```

**Interface Design Guidelines:**
- All methods must accept `context.Context` as first parameter
- Use concrete entity types as parameters
- Return pointers to entity types or error
- Include standard CRUD operations: Create, Read, Update, Delete
- Add List operation for retrieving multiple records
- Use descriptive method names

### Step 3: Generate Mocks

Generate mocks automatically using the Makefile command. This creates mock implementations for testing.

```bash
make repository-mocks
```

This command:
- Scans all files in `backend/repository/interfaces/`
- Generates mock files in `backend/repository/mock/`
- Creates files named `<name>_mock.go`

Example generated file: `backend/repository/mock/user.repository_mock.go`

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: backend/repository/interfaces/user.repository_interface.go

package mock

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	entity "github.com/kamil5b/clean-go-vite-react/backend/model/entity"
	uuid "github.com/google/uuid"
)

type MockUserRepository struct {
	ctrl     *gomock.Controller
	recorder *MockUserRepositoryMockRecorder
}

func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository {
	// ...
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder {
	return m.recorder
}
```

**Do not edit generated mock files.** They are regenerated with `make repository-mocks`.

### Step 4: Implement Repository with GORM

Create GORM implementation in `backend/repository/implementations/<name>/` directory.

**Step 4a: Create main repository file**

Create `backend/repository/implementations/user/user.gorm.go`:

```go
package user

import (
	"github.com/kamil5b/clean-go-vite-react/backend/model/entity"
	"github.com/kamil5b/clean-go-vite-react/backend/repository/interfaces"
	"gorm.io/gorm"
)

// GORMUserRepository is a GORM implementation of UserRepository
type GORMUserRepository struct {
	db *gorm.DB
}

// UserModel represents the users table schema
type UserModel = entity.UserEntity

// Verify interface implementation
var _ interfaces.UserRepository = (*GORMUserRepository)(nil)

// NewGORMUserRepository creates a new GORM user repository
func NewGORMUserRepository(db *gorm.DB) (interfaces.UserRepository, error) {
	// Auto-migrate the schema
	if err := db.AutoMigrate(&UserModel{}); err != nil {
		return nil, err
	}

	return &GORMUserRepository{
		db: db,
	}, nil
}
```

**Key Points:**
- Name struct `GORM<Name>Repository` 
- Embed `*gorm.DB` for database access
- Create alias `<Name>Model = entity.<Name>Entity`
- Add interface verification: `var _ interfaces.UserRepository = (*GORMUserRepository)(nil)`
- Handle schema migrations in constructor
- Return interface type, not concrete type

**Step 4b: Implement individual methods**

Create separate files for each method: `create.gorm.go`, `read.gorm.go`, etc.

Example: `backend/repository/implementations/user/create.gorm.go`

```go
package user

import (
	"context"

	"github.com/google/uuid"
	"github.com/kamil5b/clean-go-vite-react/backend/model/entity"
)

// Create creates a new user in the database
func (r *GORMUserRepository) Create(ctx context.Context, user entity.UserEntity) (*uuid.UUID, error) {
	// Handle context cancellation
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}

	// Generate new UUID if not set
	if user.ID == uuid.Nil {
		user.ID = uuid.New()
	}

	// Execute database operation
	if err := r.db.WithContext(ctx).Create(&user).Error; err != nil {
		return nil, err
	}

	return &user.ID, nil
}
```

Example: `backend/repository/implementations/user/find_by_id.gorm.go`

```go
package user

import (
	"context"

	"github.com/google/uuid"
	"github.com/kamil5b/clean-go-vite-react/backend/model/entity"
	"gorm.io/gorm"
)

// FindByID retrieves a user by ID
func (r *GORMUserRepository) FindByID(ctx context.Context, id uuid.UUID) (*entity.UserEntity, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}

	var user entity.UserEntity
	if err := r.db.WithContext(ctx).First(&user, "id = ?", id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, err
	}

	return &user, nil
}
```

Example: `backend/repository/implementations/user/update.gorm.go`

```go
package user

import (
	"context"

	"github.com/google/uuid"
	"github.com/kamil5b/clean-go-vite-react/backend/model/entity"
)

// Update updates an existing user
func (r *GORMUserRepository) Update(ctx context.Context, id uuid.UUID, user entity.UserEntity) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	user.ID = id
	return r.db.WithContext(ctx).Save(&user).Error
}
```

Example: `backend/repository/implementations/user/delete.gorm.go`

```go
package user

import (
	"context"

	"github.com/google/uuid"
)

// Delete deletes a user (soft delete)
func (r *GORMUserRepository) Delete(ctx context.Context, id uuid.UUID) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	return r.db.WithContext(ctx).Delete(&UserModel{}, "id = ?", id).Error
}
```

## Best Practices

### 1. Always Pass Context

All repository methods must accept and use `context.Context`:

```go
// ✅ Good
func (r *GORMUserRepository) Create(ctx context.Context, user entity.UserEntity) (*uuid.UUID, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}
	return r.db.WithContext(ctx).Create(&user).Error
}

// ❌ Bad
func (r *GORMUserRepository) Create(user entity.UserEntity) error {
	return r.db.Create(&user).Error
}
```

### 2. Use UUID for Primary Keys

Always use `uuid.UUID` instead of integers:

```go
// ✅ Good
type UserEntity struct {
	ID uuid.UUID `gorm:"primaryKey"`
}

// ❌ Bad
type UserEntity struct {
	ID int `gorm:"primaryKey"`
}
```

### 3. Include Timestamp Fields

Always include audit timestamps:

```go
type UserEntity struct {
	ID        uuid.UUID `gorm:"primaryKey"`
	Email     string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"` // for soft deletes
}
```

### 4. Use Soft Deletes for Data Retention

Include `DeletedAt` field for auditing and recovery:

```go
// Soft delete
db.Delete(&user) // Sets DeletedAt, doesn't remove record

// Query excludes soft-deleted records by default
var users []UserEntity
db.Find(&users) // Only returns non-deleted records

// Force hard delete if needed
db.Unscoped().Delete(&user) // Physically removes record
```

### 5. Return Interface Types, Not Concrete Types

```go
// ✅ Good
func NewGORMUserRepository(db *gorm.DB) (interfaces.UserRepository, error) {
	return &GORMUserRepository{db: db}, nil
}

// ❌ Bad
func NewGORMUserRepository(db *gorm.DB) *GORMUserRepository {
	return &GORMUserRepository{db: db}
}
```

### 6. Use GORM with Context

Always use `WithContext()` to propagate context:

```go
// ✅ Good
r.db.WithContext(ctx).Create(&user)

// ❌ Bad
r.db.Create(&user)
```

### 7. Use Request Models in Service Layer

Services use request/response models, not entities. Repositories use entities:

```
Request Model (service input)
    ↓
Service Layer (business logic)
    ↓
Entity Model (database schema)
    ↓
Repository (GORM implementation)
    ↓
Database
```

### 8. Separate Methods by Concern

Create individual files for each method:

```
implementations/user/
├── user.gorm.go           # Constructor and struct
├── create.gorm.go         # Create method
├── find_by_id.gorm.go     # Read method
├── find_all.gorm.go       # List method
├── update.gorm.go         # Update method
└── delete.gorm.go         # Delete method
```

## Example Repository Structure

```
backend/repository/
├── interfaces/
│   ├── counter.repository_interface.go
│   ├── email.repository_interface.go
│   ├── message.repository_interface.go
│   └── user.repository_interface.go
├── implementations/
│   ├── counter/
│   │   ├── counter.gorm.go
│   │   ├── get_counter.gorm.go
│   │   └── increment_counter.gorm.go
│   ├── email/
│   │   ├── email.gorm.go
│   │   ├── create.gorm.go
│   │   └── find_by_id.gorm.go
│   ├── message/
│   │   ├── message.gorm.go
│   │   └── get_message.gorm.go
│   └── user/
│       ├── user.gorm.go
│       ├── create.gorm.go
│       ├── find_by_id.gorm.go
│       ├── find_all.gorm.go
│       ├── update.gorm.go
│       └── delete.gorm.go
└── mock/
    ├── counter.repository_mock.go      # Generated
    ├── email.repository_mock.go        # Generated
    ├── message.repository_mock.go      # Generated
    └── user.repository_mock.go         # Generated
```

## Common Patterns

### Pattern 1: Simple CRUD Repository

```go
// Interface
type UserRepository interface {
	Create(ctx context.Context, user entity.UserEntity) (*uuid.UUID, error)
	FindByID(ctx context.Context, id uuid.UUID) (*entity.UserEntity, error)
	Update(ctx context.Context, id uuid.UUID, user entity.UserEntity) error
	Delete(ctx context.Context, id uuid.UUID) error
	FindAll(ctx context.Context) ([]entity.UserEntity, error)
}

// Implementation
func (r *GORMUserRepository) Create(ctx context.Context, user entity.UserEntity) (*uuid.UUID, error) {
	if user.ID == uuid.Nil {
		user.ID = uuid.New()
	}
	return &user.ID, r.db.WithContext(ctx).Create(&user).Error
}
```

### Pattern 2: Query with Filters

```go
type UserRepository interface {
	FindByEmail(ctx context.Context, email string) (*entity.UserEntity, error)
	FindByName(ctx context.Context, name string) ([]entity.UserEntity, error)
}

func (r *GORMUserRepository) FindByEmail(ctx context.Context, email string) (*entity.UserEntity, error) {
	var user entity.UserEntity
	if err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, err
	}
	return &user, nil
}
```

### Pattern 3: Pagination

```go
type UserRepository interface {
	FindAllPaginated(ctx context.Context, page, pageSize int) ([]entity.UserEntity, int64, error)
}

func (r *GORMUserRepository) FindAllPaginated(ctx context.Context, page, pageSize int) ([]entity.UserEntity, int64, error) {
	var users []entity.UserEntity
	var total int64
	
	offset := (page - 1) * pageSize
	
	if err := r.db.WithContext(ctx).Model(&UserModel{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}
	
	if err := r.db.WithContext(ctx).Offset(offset).Limit(pageSize).Find(&users).Error; err != nil {
		return nil, 0, err
	}
	
	return users, total, nil
}
```

### Pattern 4: Bulk Operations

```go
type UserRepository interface {
	CreateMany(ctx context.Context, users []entity.UserEntity) error
	DeleteMany(ctx context.Context, ids []uuid.UUID) error
}

func (r *GORMUserRepository) CreateMany(ctx context.Context, users []entity.UserEntity) error {
	return r.db.WithContext(ctx).CreateInBatches(users, 100).Error
}

func (r *GORMUserRepository) DeleteMany(ctx context.Context, ids []uuid.UUID) error {
	return r.db.WithContext(ctx).Delete(&UserModel{}, "id IN ?", ids).Error
}
```

## Testing Repositories

Use the generated mocks in service tests:

```go
func TestCreateUser(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// Create mock repository
	mockRepo := mock.NewMockUserRepository(ctrl)
	
	// Setup expectations
	mockRepo.EXPECT().
		Create(gomock.Any(), gomock.Any()).
		Return(&uuid.New(), nil).
		Times(1)

	// Use in service
	svc := NewUserService(mockRepo)
	result, err := svc.CreateUser(context.Background(), &request.CreateUserRequest{...})
	
	// Assert
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
}
```

## Troubleshooting

### Mock Generation Failed

If `make repository-mocks` fails:

```bash
# Ensure mockgen is installed
go install github.com/golang/mock/cmd/mockgen@latest

# Verify interface file exists
ls backend/repository/interfaces/

# Manually generate if needed
mockgen -source=backend/repository/interfaces/user.repository_interface.go \
  -destination=backend/repository/mock/user.repository_mock.go \
  -package=mock
```

### GORM Migration Errors

If auto-migration fails:

```go
// Check entity struct tags
type UserEntity struct {
	ID uuid.UUID `gorm:"primaryKey"` // Required for GORM
}

// Manual migration in constructor
func NewGORMUserRepository(db *gorm.DB) (interfaces.UserRepository, error) {
	if err := db.AutoMigrate(&UserModel{}); err != nil {
		return nil, fmt.Errorf("failed to migrate schema: %w", err)
	}
	return &GORMUserRepository{db: db}, nil
}
```

### Context Not Propagating

Always check context in your implementation:

```go
// ✅ Good - handles context cancellation
select {
case <-ctx.Done():
	return nil, ctx.Err()
default:
}

// Pass context to GORM
r.db.WithContext(ctx).Find(&user)
```

### UUID Type Mismatches

Ensure consistent UUID usage:

```go
import "github.com/google/uuid"

// ✅ Good
func FindByID(ctx context.Context, id uuid.UUID) (*entity.UserEntity, error)

// ❌ Bad - don't use string
func FindByID(ctx context.Context, id string) (*entity.UserEntity, error)
```
